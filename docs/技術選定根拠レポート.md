# FitGraph - 技術選定根拠レポート

## 1. プロジェクト概要

**プロジェクト名**: FitGraph（フィットグラフ）
**サービス内容**: ダイエット時のモチベーション維持と運動習慣化を支援するWebアプリケーション

### 主要機能
- 体重・体脂肪率・写真による身体データ記録
- グラフによるデータ可視化（Chart.js）
- 写真によるビフォーアフター比較
- YouTube トレーニング動画の提案・再生
- LINE Bot によるリマインド機能
- OAuth 2.0 認証（Google / LINE）
- 二要素認証（2FA）対応

---

## 2. 技術スタック概要

| カテゴリ | 技術 | バージョン |
|---------|------|-----------|
| バックエンド | Ruby on Rails | 7.2.1 |
| 言語 | Ruby | 3.3.6 |
| データベース | PostgreSQL | - |
| Webサーバー | Puma | 5.0+ |
| フロントエンド | Hotwire (Turbo/Stimulus) | Turbo 8.0, Stimulus 3.2 |
| JavaScript ライブラリ | Chart.js | 4.4.9 |
| CSS フレームワーク | Tailwind CSS | 3.4.18 |
| UI コンポーネント | DaisyUI | 5.3.0 |
| ビルドツール | esbuild | 0.25.5 |
| CSS ビルド | PostCSS | 8.5.6 |
| 認証 | Devise | - |
| OAuth | OmniAuth (Google/LINE) | - |
| 二要素認証 | devise-two-factor, rotp | - |
| 画像処理 | ImageProcessing, MiniMagick | 1.12+ |
| ストレージ | AWS S3 (Active Storage) | - |
| 外部API | YouTube Data API v3 | - |
| メッセージング | LINE Messaging API | 1.30.0 |
| カレンダー | Simple Calendar | 2.0 |
| テスト | RSpec, FactoryBot | - |
| E2Eテスト | Capybara, Selenium | - |
| 静的解析 | RuboCop, Brakeman | - |
| コンテナ | Docker | - |
| デプロイ | Render | - |
| バージョン管理 | Git (Git Flow) | - |

---

## 3. 各技術の選定根拠

### 3.1 バックエンド: Ruby on Rails 7.2.1

#### 選定理由
1. **高速な開発スピード**
   - 規約優先（Convention over Configuration）により、設定ファイルを最小限に抑えられる
   - 豊富なgemエコシステムで、認証（Devise）、画像処理（Active Storage）など既存のソリューションを活用可能

2. **充実した機能**
   - Active Record による直感的なデータベース操作
   - Active Storage による画像アップロード・処理の標準サポート
   - Action Mailer による通知機能
   - Turbo/Stimulus による SPA ライクな UX

3. **セキュリティ**
   - CSRF 保護、SQL インジェクション対策が標準で実装
   - devise-two-factor による二要素認証の実装が容易

4. **学習コストと保守性**
   - Railsの規約に従うことで、チーム開発時のコード一貫性を保てる
   - 豊富なドキュメントとコミュニティ

#### 代替案との比較
- **Django (Python)**: Railsと同等の機能を持つが、Rubyエコシステムの方がWeb開発に特化している
- **Laravel (PHP)**: 同様にMVCフレームワークだが、Railsの方が認証・画像処理周りのgemが充実
- **Node.js (Express)**: 非同期処理に強いが、フルスタックフレームワークではなく、認証やORM等を個別に選定する必要がある

---

### 3.2 データベース: PostgreSQL

#### 選定理由
1. **信頼性と堅牢性**
   - ACID特性に完全準拠した、エンタープライズグレードのRDBMS
   - データ整合性が重要な体重・体脂肪率等の記録管理に最適

2. **豊富な機能**
   - JSON/JSONB型によるセミストラクチャードデータの保存が可能
   - 全文検索、GISデータなど拡張性が高い
   - 複雑なクエリやトランザクションに対応

3. **Railsとの相性**
   - Active Recordが標準でPostgreSQLをサポート
   - マイグレーション機能との統合がスムーズ

4. **スケーラビリティ**
   - 大量データの処理性能が高い
   - ユーザー増加に伴うデータ量の増加に対応可能

#### 代替案との比較
- **MySQL**: 広く使われているが、PostgreSQLの方が標準SQL準拠度が高く、高度な機能を持つ
- **SQLite**: 開発環境には適しているが、本番環境での並行アクセスには不向き
- **MongoDB (NoSQL)**: スキーマレスで柔軟だが、リレーショナルデータの整合性管理が煩雑

---

### 3.3 フロントエンド: Hotwire (Turbo/Stimulus)

#### 選定理由
1. **シンプルなアーキテクチャ**
   - サーバーサイドでHTMLをレンダリング、フロントエンド側は最小限のJavaScript
   - React/Vue等のSPAフレームワークと比較して学習コストが低い

2. **Turbo によるSPAライクな体験**
   - ページ遷移時に全体をリロードせず、変更部分のみを更新
   - Turbo Frames / Turbo Streams による部分更新
   - ネイティブアプリのような滑らかなUX

3. **Stimulus によるインタラクティブ性**
   - 軽量なJavaScriptフレームワーク
   - HTML属性ベースでコントローラーをアタッチ
   - Chart.js等の外部ライブラリとの統合が容易

4. **Rails との統合**
   - Rails 7 からデフォルトで組み込まれており、設定不要
   - サーバーサイドレンダリングのため、SEOに有利

#### 代替案との比較
- **React/Vue/Angular**: より複雑なSPAを構築できるが、状態管理・APIエンドポイント設計が複雑化
- **jQuery**: 古典的な手法だが、コードが煩雑になりやすい
- **HTMX**: Hotwireと同様のアプローチだが、Railsとの統合度ではHotwireに劣る

---

### 3.4 CSSフレームワーク: Tailwind CSS + DaisyUI

#### 選定理由

**Tailwind CSS**
1. **ユーティリティファーストのアプローチ**
   - HTML内でクラス名を組み合わせてスタイリング
   - カスタムCSSファイルを書く必要が最小限
   - レスポンシブデザインが容易（sm:, md:, lg: プレフィックス）

2. **高いカスタマイズ性**
   - tailwind.config.jsで色・スペーシング・ブレークポイントをカスタマイズ可能
   - プロジェクト固有のデザインシステムを構築しやすい

3. **本番ビルドでの最適化**
   - PurgeCSS により未使用のCSSを自動削除
   - ファイルサイズが最小化され、パフォーマンス向上

**DaisyUI**
1. **コンポーネントライブラリ**
   - ボタン、カード、モーダル等のUIコンポーネントを提供
   - Tailwindのユーティリティクラスの上に構築されており、統一感のあるデザイン

2. **開発速度の向上**
   - 一貫したデザインをすぐに適用可能
   - カスタマイズも容易

#### 代替案との比較
- **Bootstrap**: より伝統的だが、カスタマイズが煩雑で、独自のJavaScriptに依存
- **Material UI**: React専用で、Railsとの統合には不向き
- **素のCSS**: 完全な自由度があるが、開発速度が低下

---

### 3.5 ビルドツール: esbuild + PostCSS

#### 選定理由

**esbuild**
1. **高速なビルド**
   - Go言語で書かれており、Webpack等と比較して10〜100倍高速
   - 開発時のホットリロード体験が向上

2. **シンプルな設定**
   - 最小限の設定で動作
   - Rails の jsbundling-rails gem と統合されている

3. **モダンなJavaScript対応**
   - ES6+ の構文をサポート
   - Tree shaking によるバンドルサイズ最適化

**PostCSS**
1. **Tailwind CSS との統合**
   - Tailwind CSS は PostCSS プラグインとして動作
   - Autoprefixer による自動ベンダープレフィックス付与

2. **拡張性**
   - プラグインエコシステムが豊富
   - 必要に応じて機能を追加可能

#### 代替案との比較
- **Webpack**: より機能豊富だが、設定が複雑でビルド速度が遅い
- **Vite**: 高速だが、Rails との統合はesbuildの方がスムーズ
- **Sprockets**: Rails伝統のアセットパイプラインだが、モダンなJavaScriptには不向き

---

### 3.6 認証: Devise + OmniAuth

#### 選定理由

**Devise**
1. **Rails標準の認証gem**
   - メール/パスワード認証を簡単に実装
   - セッション管理、パスワードリセット、メール確認等の機能が組み込み

2. **カスタマイズ性**
   - コントローラー、ビュー、モデルをオーバーライド可能
   - 二要素認証（devise-two-factor）との統合が容易

3. **セキュリティ**
   - bcrypt によるパスワードハッシュ化
   - セッション固定攻撃、CSRF攻撃への対策

**OmniAuth (Google OAuth2 / LINE)**
1. **ソーシャルログインの実装**
   - ユーザーの登録・ログインの手間を削減
   - Google / LINE のアカウントで簡単にログイン可能

2. **セキュリティ**
   - OAuthプロトコルにより、パスワードをアプリ側で保持しない
   - omniauth-rails_csrf_protection による CSRF 攻撃対策

3. **ユーザービリティ**
   - ユーザーが既に持っているアカウントを活用できる
   - 新規登録のハードルが下がる

**devise-two-factor + rotp**
1. **二要素認証の実装**
   - セキュリティを強化
   - TOTPベースのワンタイムパスワード
   - rqrcode でQRコードを生成し、Google Authenticator等と連携

#### 代替案との比較
- **自前実装**: セキュリティリスクが高く、開発コストが大きい
- **Authlogic**: Deviseほど機能豊富ではない
- **Sorcery**: シンプルだが、OAuthや2FA統合が煩雑

---

### 3.7 画像処理・ストレージ: Active Storage + AWS S3

#### 選定理由

**Active Storage**
1. **Rails標準の画像管理**
   - ファイルアップロードをActive Recordモデルに直接アタッチ
   - 複数のストレージサービス（ローカル、S3、GCS等）に対応

2. **画像処理**
   - ImageProcessing + MiniMagick によるリサイズ、トリミング
   - バリアント機能により、異なるサイズの画像を動的生成

3. **開発効率**
   - 設定が簡単で、モデルに `has_one_attached :image` を追加するだけ

**AWS S3**
1. **信頼性とスケーラビリティ**
   - 99.999999999% の耐久性
   - 容量制限なし、ユーザー増加に対応可能

2. **コストパフォーマンス**
   - 従量課金制で、初期費用不要
   - 開発段階では低コスト

3. **CDN連携**
   - CloudFrontと連携し、画像配信を高速化可能

**ImageProcessing + MiniMagick**
1. **画像の最適化**
   - アップロード時に画像をリサイズし、ストレージ容量を削減
   - WebP等のモダンなフォーマットに変換可能

2. **セキュリティ**
   - 悪意のある画像ファイルの検出・処理

#### 代替案との比較
- **Paperclip**: 非推奨（deprecated）であり、Active Storage が後継
- **CarrierWave**: 機能豊富だが、Active Storage の方がRailsとの統合度が高い
- **ローカルストレージ**: 小規模なら可能だが、スケーラビリティに欠ける
- **Cloudinary**: 画像処理に特化しているが、コストが高い

---

### 3.8 外部API連携

#### 3.8.1 YouTube Data API v3

**選定理由**
1. **動画検索・表示機能**
   - ユーザーのトレーニングニーズに合った動画を検索
   - 動画の埋め込み再生が可能

2. **豊富なメタデータ**
   - 動画のタイトル、説明、サムネイル、再生回数等を取得
   - ユーザーに最適な動画を提案

3. **公式API**
   - Googleが提供する公式APIで、信頼性が高い
   - google-apis-youtube_v3 gem で簡単に統合

**代替案との比較**
- **Vimeo API**: YouTubeの方がコンテンツ量が圧倒的に多い
- **自前の動画ホスティング**: 動画のホスティングコストが高く、著作権管理が困難

---

#### 3.8.2 LINE Messaging API

**選定理由**
1. **プッシュ通知機能**
   - ユーザーがトレーニング時間を設定し、定刻にリマインド
   - メール通知よりも開封率が高い

2. **高いユーザー普及率**
   - 日本国内でのLINEの利用率は非常に高い
   - ユーザーが日常的に使用しているアプリで通知を受け取れる

3. **Bot開発の容易さ**
   - line-bot-api gem で簡単に統合
   - Webhook による双方向のやり取りが可能

4. **認証連携**
   - LINE Login (OmniAuth) でアカウント連携が容易

**代替案との比較**
- **メール通知**: 開封率が低く、スパム扱いされるリスク
- **SMS通知**: コストが高い
- **Slack/Discord**: ビジネス向けで、一般ユーザーには不向き

---

#### 3.8.3 Simple Calendar

**選定理由**
1. **カレンダー表示の実装**
   - 月間カレンダー形式で体重記録を表示
   - 日付ごとのデータを視覚的に確認可能
   - ユーザーが特定の日付をクリックして記録を追加・編集

2. **シンプルで軽量**
   - JavaScriptに依存せず、サーバーサイドでHTMLをレンダリング
   - Hotwireとの相性が良く、Turboによる部分更新が可能
   - 設定がシンプルで、すぐに導入可能

3. **高いカスタマイズ性**
   - ビューテンプレートを自由にカスタマイズ可能
   - Tailwind CSSと組み合わせて、独自のデザインを実装
   - 週の開始曜日、表示形式などを柔軟に設定

4. **Railsとの統合**
   - Active Recordと連携し、データベースからデータを取得
   - `simple_calendar_for` ヘルパーメソッドで簡単に実装
   - 日付範囲のクエリ最適化が容易

5. **パフォーマンス**
   - 月単位でのデータ取得により、不要なクエリを削減
   - N+1問題を避けやすい設計

**代替案との比較**
- **FullCalendar.js**: 高機能なJavaScriptライブラリだが、体重記録のような単純なカレンダーには過剰
- **Flatpickr**: 日付ピッカーに特化しており、月間カレンダー表示には不向き
- **自前実装**: 日付計算、曜日の配置などが煩雑で、バグが発生しやすい
- **table_calendar**: Simple Calendarとほぼ同等だが、コミュニティが小さくメンテナンス頻度が低い

**FitGraphでの活用**
- 体重記録画面で月間カレンダーを表示
- 記録済みの日付にはデータを表示し、未記録の日付には追加ボタンを表示
- カレンダー上で記録の傾向（連続記録日数など）を視覚的に把握可能

---

### 3.9 テスト環境

#### 3.9.1 RSpec

**選定理由**
1. **BDD（振る舞い駆動開発）**
   - `describe`, `context`, `it` による可読性の高いテスト記述
   - テストがドキュメントとしても機能

2. **豊富なマッチャー**
   - expect構文による直感的なアサーション
   - shoulda-matchers によるモデルバリデーションテストの簡略化

3. **Railsとの統合**
   - rspec-rails gem により、Rails専用のヘルパーやジェネレータを提供
   - request spec, model spec, system spec等の種類別テスト

**代替案との比較**
- **Minitest**: Railsのデフォルトだが、RSpecの方が表現力が高い
- **Test::Unit**: 古典的な手法で、モダンな機能に欠ける

---

#### 3.9.2 FactoryBot

**選定理由**
1. **テストデータの生成**
   - モデルのテストデータを簡単に生成
   - Fixtureと比較して、柔軟性が高い

2. **可読性**
   - `create(:user, email: "test@example.com")` のように直感的
   - アソシエーションの自動生成

3. **保守性**
   - モデル変更時にファクトリーのみを修正すれば、全テストに反映

**代替案との比較**
- **Fixture**: YAML形式で静的だが、柔軟性に欠ける
- **手動生成**: テストコードが冗長になる

---

#### 3.9.3 Capybara + Selenium

**選定理由**
1. **E2Eテスト（システムテスト）**
   - ブラウザを自動操作し、実際のユーザー操作をシミュレート
   - JavaScript の動作も含めてテスト可能

2. **Railsとの統合**
   - RSpecのsystem specとして利用可能
   - `visit`, `click_button`, `fill_in` 等の直感的なDSL

3. **複数ブラウザ対応**
   - Selenium WebDriverによりChrome、Firefox等に対応

**代替案との比較**
- **Playwright/Cypress**: モダンだが、Railsエコシステムとの統合はCapybaraに劣る
- **手動テスト**: 時間がかかり、再現性に欠ける

---

### 3.10 静的解析・セキュリティ

#### 3.10.1 RuboCop

**選定理由**
1. **コードスタイルの統一**
   - Ruby Style Guideに準拠したコードチェック
   - チーム開発時のコード品質を保つ

2. **自動修正機能**
   - `rubocop -a` で自動的にコードを修正
   - インデント、改行、命名規則等を統一

3. **Rails専用ルール**
   - rubocop-rails-omakase により、Railsのベストプラクティスに準拠

**代替案との比較**
- **StandardRB**: より厳格だが、カスタマイズ性に欠ける
- **手動レビュー**: 人的コストが高く、一貫性に欠ける

---

#### 3.10.2 Brakeman

**選定理由**
1. **セキュリティ脆弱性の検出**
   - SQLインジェクション、XSS、CSRF等の脆弱性を静的解析
   - 開発段階で脆弱性を早期発見

2. **CI/CDとの統合**
   - GitHub Actions等で自動実行し、継続的にセキュリティチェック

3. **無料でオープンソース**
   - 商用ツールと同等の機能を無料で利用可能

**代替案との比較**
- **手動セキュリティレビュー**: 専門知識が必要で、時間がかかる
- **商用ツール（Snyk等）**: より高度だが、コストがかかる

---

### 3.11 コンテナ: Docker

#### 選定理由
1. **開発環境の統一**
   - OS依存の問題を解決
   - チームメンバー全員が同じ環境で開発可能

2. **本番環境との一致**
   - 開発環境と本番環境の差異を最小化
   - "自分の環境では動く" 問題を解消

3. **依存関係の管理**
   - Ruby、Node.js、PostgreSQL等の依存関係をコンテナ内に閉じ込める
   - ホストOSを汚さない

4. **デプロイの簡素化**
   - Dockerイメージをそのままデプロイ
   - Renderなどのクラウドサービスとの相性が良い

**代替案との比較**
- **仮想マシン**: リソース消費が多く、起動が遅い
- **ローカルインストール**: 環境依存の問題が発生しやすい
- **Vagrant**: Dockerの方が軽量で高速

---

### 3.12 デプロイ: Render

#### 選定理由
1. **簡単なデプロイ**
   - GitHubリポジトリと連携し、自動デプロイ
   - Dockerfileを使用した柔軟なデプロイが可能

2. **無料プラン**
   - 個人開発やMVPの検証に最適
   - PostgreSQL、Redisなども無料で利用可能

3. **スケーラビリティ**
   - ユーザー増加に応じて有料プランにアップグレード可能
   - 水平スケーリングに対応

4. **Herokuの代替**
   - Herokuの無料プラン廃止に伴い、Renderが人気

**代替案との比較**
- **Heroku**: 有料化により、個人開発には不向き
- **AWS (EC2/ECS)**: より柔軟だが、設定が複雑でコストがかかる
- **Vercel/Netlify**: フロントエンド特化で、Railsには不向き
- **Railway**: Renderと同様だが、コミュニティがやや小さい

---

## 4. 技術選定の総括

### 4.1 全体アーキテクチャの方針

本プロジェクトでは、以下の方針に基づいて技術選定を行いました。

1. **シンプルさの追求**
   - 複雑なマイクロサービスやSPAではなく、モノリシックなRailsアプリケーション
   - Hotwireによるサーバーサイドレンダリングで、フロントエンド/バックエンドの境界を曖昧にし、開発効率を向上

2. **開発速度の重視**
   - Railsの"Convention over Configuration"により、設定を最小化
   - Devise、Active Storage等の既存gemを活用し、車輪の再発明を避ける

3. **スケーラビリティの確保**
   - PostgreSQL、AWS S3により、ユーザー増加に対応可能
   - Dockerにより、水平スケーリングが容易

4. **セキュリティの強化**
   - Devise、OmniAuth、二要素認証により、ユーザーアカウントを保護
   - Brakeman、RuboCopにより、コード品質とセキュリティを継続的にチェック

5. **ユーザー体験の向上**
   - Hotwireによる高速なページ遷移
   - Tailwind CSS + DaisyUIによる洗練されたUI
   - LINE Bot、YouTube API連携により、ユーザーの日常に溶け込むサービス

---

### 4.2 今後の拡張性

以下の技術は、今後の機能拡張に備えて選定されています。

- **GraphQL**: RESTful APIの代わりに、モバイルアプリ開発時に検討
- **Redis**: Action Cableやキャッシュ機能の導入時に追加
- **Sidekiq**: バックグラウンドジョブ（動画サムネイル生成、一括メール送信等）の実装時に導入
- **Elasticsearch**: 動画検索機能の高度化時に検討

---

### 4.3 技術選定の成功要因

1. **Railsエコシステムの活用**
   - 認証、画像処理、外部API連携等、Railsの豊富なgemを活用することで開発速度を大幅に向上

2. **モダンなフロントエンド技術**
   - Hotwire、Tailwind CSS、Chart.jsにより、SPAに匹敵するUXを実現

3. **クラウドサービスの活用**
   - AWS S3、Render等のクラウドサービスを活用し、インフラ管理の負担を最小化

4. **セキュリティとテストの重視**
   - RSpec、Brakeman、二要素認証により、品質とセキュリティを担保

---

## 5. 参考資料

- [Ruby on Rails Guides](https://guides.rubyonrails.org/)
- [Hotwire Documentation](https://hotwired.dev/)
- [Tailwind CSS Documentation](https://tailwindcss.com/)
- [DaisyUI Documentation](https://daisyui.com/)
- [Devise Documentation](https://github.com/heartcombo/devise)
- [YouTube Data API Documentation](https://developers.google.com/youtube/v3)
- [LINE Messaging API Documentation](https://developers.line.biz/ja/docs/messaging-api/)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Docker Documentation](https://docs.docker.com/)

---

**作成日**: 2025年12月8日
**作成者**: Claude Code
**プロジェクト**: FitGraph（フィットグラフ）
