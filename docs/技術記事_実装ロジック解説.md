# FitGraph 技術記事：機能別実装ロジック解説

## 目次
1. [概要](#概要)
2. [全体アーキテクチャ](#全体アーキテクチャ)
3. [ユーザー認証機能](#1-ユーザー認証機能)
4. [プロフィール管理機能](#2-プロフィール管理機能)
5. [身体記録機能](#3-身体記録機能)
6. [進捗可視化機能](#4-進捗可視化機能)
7. [YouTube動画連携機能](#5-youtube動画連携機能)
8. [お気に入り動画管理機能](#6-お気に入り動画管理機能)
9. [LINE Bot リマインド機能](#7-line-bot-リマインド機能)
10. [まとめ](#まとめ)

---

## 概要

### アプリケーション概要
FitGraphは、ダイエット時のモチベーション維持と運動の習慣化を支援するWebアプリケーションです。

**解決する課題**
- ダイエット中のモチベーション低下
- 身体の変化が実感しづらい
- 自分に合ったトレーニング動画を探すのが大変
- 記録が面倒で続かない

**主な機能**
1. 体重・体脂肪率・身体写真の記録
2. グラフによる推移の可視化
3. 写真のスライダー表示で変化を確認
4. プロフィールに基づくYouTube動画推薦
5. LINEによるリマインド通知

### 使用技術スタック
- **バックエンド**: Ruby on Rails 7.2.1, Ruby 3.3.6
- **フロントエンド**: Hotwire (Turbo/Stimulus), JavaScript, Chart.js, DaisyUI
- **CSSフレームワーク**: Tailwind CSS
- **Web API**: Google API (OAuth 2.0, YouTube Data API), LINE Messaging API
- **ストレージ**: Active Storage (画像アップロード)
- **データベース**: PostgreSQL
- **インフラ**: Render, Docker

---

## 全体アーキテクチャ

### システム構成図
```
┌─────────────┐
│   ブラウザ   │
└──────┬──────┘
       │ HTTPS
┌──────▼──────────────────────────┐
│   Rails Application (Render)    │
│  ┌─────────────────────────┐   │
│  │   Controller Layer      │   │
│  └───────┬─────────────────┘   │
│  ┌───────▼─────────────────┐   │
│  │   Service Layer         │   │
│  │  - ビジネスロジック      │   │
│  └───────┬─────────────────┘   │
│  ┌───────▼─────────────────┐   │
│  │   Model Layer           │   │
│  └───────┬─────────────────┘   │
└──────────┼─────────────────────┘
           │
    ┌──────┴──────┐
    ▼             ▼
┌────────┐   ┌────────────┐
│PostgreSQL│   │Active Storage│
└────────┘   └────────────┘

External APIs:
- Google OAuth 2.0
- YouTube Data API v3
- LINE Messaging API
```

### アプリケーション構造
FitGraphは、標準的なRailsのMVCアーキテクチャに加えて、**Service層**を導入しています。

#### ディレクトリ構成

FitGraphのアプリケーション構造を、主要なディレクトリごとに詳しく説明します。

```
app/
├── controllers/              # MVCのC: リクエスト処理・ルーティング
│   ├── application_controller.rb      # 全コントローラの基底クラス
│   ├── body_records_controller.rb     # 身体記録のCRUD・カレンダー表示
│   ├── favorite_videos_controller.rb  # お気に入り動画の追加・削除
│   ├── line_bot_controller.rb         # LINE Bot Webhook処理
│   ├── profiles_controller.rb         # プロフィール登録・編集
│   ├── progress_controller.rb         # グラフ・写真スライダー表示
│   ├── recommended_videos_controller.rb # YouTube動画推薦
│   ├── static_pages_controller.rb     # トップ・規約・使い方ページ
│   ├── users_controller.rb            # ユーザー情報管理
│   └── users/                         # Devise認証関連
│       ├── omniauth_callbacks_controller.rb  # Google/LINE OAuth認証
│       ├── passwords_controller.rb           # パスワードリセット
│       ├── registrations_controller.rb       # ユーザー登録
│       ├── sessions_controller.rb            # ログイン・ログアウト
│       ├── two_factor_authentication_controller.rb  # 2FA認証
│       └── two_factor_settings_controller.rb # 2FA設定
│
├── models/                   # MVCのM: データモデル・バリデーション・リレーション
│   ├── application_record.rb      # 全モデルの基底クラス
│   ├── user.rb                    # ユーザー（Devise認証・OAuth・2FA）
│   ├── profile.rb                 # プロフィール（User 1対1）
│   ├── body_record.rb             # 身体記録（User 1対多）
│   ├── favorite_video.rb          # お気に入り動画（User 1対多）
│   └── recommended_video.rb       # 推薦動画キャッシュ
│
├── services/                 # ビジネスロジック層（Fat Controllerを避けるため）
│   ├── body_record_photo_service.rb   # 画像の圧縮・リサイズ処理
│   ├── favorite_video_service.rb      # お気に入り動画の登録ロジック
│   ├── line_bot_service.rb            # LINE Botメッセージハンドリング
│   ├── progress_data_service.rb       # グラフ用データの整形・集計
│   ├── recommended_video_service.rb   # 動画推薦・キャッシュ管理
│   ├── youtube_api_service.rb         # YouTube Data API呼び出し
│   └── youtube_service.rb             # YouTube動画検索・フィルタリング
│
├── views/                    # MVCのV: 表示層（ERB + Hotwire）
│   ├── layouts/
│   │   └── application.html.erb           # 全ページ共通レイアウト
│   ├── shared/                            # 共有パーシャル
│   │   ├── _header.html.erb               # ヘッダーナビゲーション
│   │   ├── _footer.html.erb               # フッター
│   │   ├── _flash.html.erb                # フラッシュメッセージ
│   │   └── _button.html.erb               # ボタンコンポーネント
│   ├── body_records/
│   │   ├── top.html.erb                   # カレンダートップ
│   │   ├── new.html.erb                   # 記録新規作成
│   │   ├── edit.html.erb                  # 記録編集
│   │   ├── _form.html.erb                 # フォームパーシャル
│   │   └── _calendar.html.erb             # カレンダー表示
│   ├── progress/
│   │   ├── index.html.erb                 # グラフ・統計メインページ
│   │   ├── _graph_photo_tab.html.erb      # タブ切り替え
│   │   ├── _graph.html.erb                # Chart.jsグラフ
│   │   ├── _photo.html.erb                # 写真スライダー
│   │   └── _stats_table.html.erb          # 統計テーブル
│   ├── profiles/
│   │   ├── show.html.erb                  # プロフィール詳細
│   │   └── edit.html.erb                  # プロフィール編集
│   ├── recommended_videos/
│   │   └── index.html.erb                 # 推薦動画一覧
│   ├── static_pages/
│   │   ├── top.html.erb                   # トップページ
│   │   ├── how_to.html.erb                # 使い方ガイド
│   │   ├── terms.html.erb                 # 利用規約
│   │   └── privacy.html.erb               # プライバシーポリシー
│   ├── users/
│   │   ├── new.html.erb                   # ユーザー新規登録
│   │   ├── two_factor_authentication/
│   │   │   └── new.html.erb               # 2FA認証画面
│   │   └── two_factor_settings/
│   │       └── show.html.erb              # 2FA設定・QRコード表示
│   └── devise/                            # Devise認証画面
│       ├── sessions/
│       │   └── new.html.erb               # ログイン
│       ├── registrations/
│       │   ├── new.html.erb               # 新規登録
│       │   └── edit.html.erb              # アカウント編集
│       ├── passwords/
│       │   ├── new.html.erb               # パスワードリセット申請
│       │   └── edit.html.erb              # パスワード変更
│       └── shared/
│           ├── _links.html.erb            # 認証関連リンク
│           └── _error_messages.html.erb   # エラーメッセージ
│
├── javascript/               # フロントエンド処理（Stimulus.js）
│   ├── application.js            # エントリーポイント
│   └── controllers/              # Stimulus Controllers
│       ├── accordion_controller.js       # アコーディオンUI
│       ├── camera_controller.js          # Webカメラ撮影・プレビュー
│       ├── dropdown_controller.js        # ドロップダウンメニュー
│       ├── loading_controller.js         # ローディング表示
│       ├── photo_switcher_controller.js  # 写真スライダー切り替え
│       └── progress_controller.js        # Chart.jsグラフ描画・期間切替
│
├── assets/
│   ├── stylesheets/              # CSS
│   │   ├── application.tailwind.css  # Tailwind CSS + DaisyUI
│   │   └── components/               # カスタムコンポーネントCSS
│   └── images/                       # 画像ファイル
│
├── jobs/                     # バックグラウンドジョブ（Sidekiq）
│   ├── application_job.rb        # 全ジョブの基底クラス
│   └── notification_job.rb       # LINE通知送信ジョブ
│
├── channels/                 # Action Cable（WebSocket）
│   └── application_cable/
│       ├── channel.rb
│       └── connection.rb
│
└── helpers/                  # ビューヘルパー
    ├── application_helper.rb
    ├── body_records_helper.rb
    ├── progress_helper.rb
    └── line_bot_helper.rb

config/
├── routes.rb                 # ルーティング定義
├── application.rb            # Rails全体設定
├── database.yml              # PostgreSQL接続設定
├── puma.rb                   # Webサーバー設定
├── cable.yml                 # Action Cable設定
├── storage.yml               # Active Storage設定
├── initializers/             # 初期化処理
│   ├── devise.rb             # Devise認証設定
│   ├── assets.rb             # アセットパイプライン設定
│   ├── meta_tags.rb          # SEO用メタタグ設定
│   └── filter_parameter_logging.rb  # ログフィルタリング
├── locales/                  # 多言語対応（i18n）
│   ├── ja.yml                # 日本語翻訳
│   ├── en.yml                # 英語翻訳
│   ├── devise.ja.yml         # Devise日本語化
│   └── devise.en.yml         # Devise英語
└── environments/             # 環境別設定
    ├── development.rb        # 開発環境
    ├── test.rb               # テスト環境
    └── production.rb         # 本番環境（Render）

db/
├── migrate/                  # マイグレーションファイル
│   ├── 20250605110000_create_users.rb
│   ├── 20250606043745_add_devise_to_users.rb
│   ├── 20250606150427_create_profiles.rb
│   ├── 20250605120527_create_body_records.rb
│   ├── 20250605110113_create_active_storage_tables.active_storage.rb
│   ├── 20250620174724_create_recommended_videos.rb
│   ├── 20250621000000_add_condition_fields_to_recommended_videos.rb
│   ├── 20250621161033_remove_user_id_from_recommended_videos.rb
│   ├── 20250629152223_create_favorite_videos.rb
│   ├── 20250630180000_change_target_weight_to_integer_in_profiles.rb
│   ├── 20250630180001_add_channel_title_to_favorite_videos.rb
│   ├── 20250701235935_add_omniauth_to_users.rb
│   ├── 20250701235956_add_index_uid_and_provider_to_users.rb
│   └── 20250714021434_add_devise_two_factor_to_users.rb
├── schema.rb                 # DBスキーマ（migrate後に自動生成）
└── seeds.rb                  # 初期データ投入スクリプト

spec/                         # RSpecテスト
├── models/                   # モデルテスト
│   ├── user_spec.rb              # Userモデル
│   ├── profile_spec.rb           # Profileモデル
│   ├── body_record_spec.rb       # BodyRecordモデル
│   ├── favorite_video_spec.rb    # FavoriteVideoモデル
│   └── recommended_video_spec.rb # RecommendedVideoモデル
├── system/                   # 統合テスト（ブラウザ操作）
│   ├── user_registration_system_spec.rb  # ユーザー登録
│   ├── user_login_system_spec.rb         # ログイン
│   ├── sns_authentication_spec.rb        # SNS認証
│   ├── body_record_system_spec.rb        # 身体記録
│   ├── progress_system_spec.rb           # グラフ表示
│   ├── calendar_top_system_spec.rb       # カレンダー
│   ├── profiles_system_spec.rb           # プロフィール
│   ├── videos_system_spec.rb             # 動画機能
│   ├── public_access_system_spec.rb      # 公開ページアクセス
│   └── protected_access_system_spec.rb   # 認証保護ページ
├── password_reset_system_spec.rb # パスワードリセット
└── rails_helper.rb           # RSpec設定

lib/
└── tasks/                    # Rakeタスク
    ├── assets.rake           # アセットプリコンパイル設定
    └── reencrypt_encryption.rake  # 暗号化キー再生成

public/                       # 静的ファイル（直接配信）
└── assets/                   # コンパイル済みアセット（本番環境）

Gemfile                       # Ruby gem依存関係
Gemfile.lock                  # gemバージョン固定
package.json                  # Node.js依存パッケージ
yarn.lock                     # yarnバージョン固定
Dockerfile                    # Docker設定
docker-compose.yml            # Docker Compose設定
tailwind.config.js            # Tailwind CSS設定
```

### 設計思想

#### Service層を導入した理由

**1. Fat Controllerの回避**
Controllerが肥大化すると、テストが困難になり、保守性が低下します。複雑なビジネスロジックをServiceに分離することで、Controllerは「リクエストを受け取り、Serviceを呼び出し、レスポンスを返す」というシンプルな責務に集中できます。

**2. 再利用性の向上**
例えば、YouTube APIの呼び出しロジックを`YoutubeApiService`に切り出すことで、複数のControllerから同じロジックを再利用できます。

**3. テストのしやすさ**
Serviceクラスは単体でテスト可能であり、モックやスタブを使った柔軟なテストが書けます。

**4. 関心の分離**
- **Model**: データの永続化、バリデーション
- **Service**: ビジネスロジック、外部API連携
- **Controller**: HTTPリクエスト/レスポンスの制御

このように責務を分離することで、コードの見通しが良くなります。

---

## 1. ユーザー認証機能

### 機能概要
FitGraphでは、**Google OAuth 2.0**と**LINE認証**によるソーシャルログインを実装しています。また、**二要素認証（2FA）**にも対応しています。

### 技術選定理由

**なぜOAuth 2.0を選んだのか**
- ユーザーがパスワードを管理する必要がない
- セキュリティリスクの低減（パスワード漏洩の心配がない）
- ユーザー体験の向上（既存のGoogle/LINEアカウントでログイン可能）

**Deviseの採用**
- Railsで最も普及している認証ライブラリ
- OmniAuth連携が容易
- 二要素認証プラグイン（devise-two-factor）が利用可能

### データモデル

```ruby
# app/models/user.rb
class User < ApplicationRecord
  has_one :profile, dependent: :destroy
  has_many :body_records
  has_many :favorite_videos, dependent: :destroy

  devise :database_authenticatable,
         :two_factor_authenticatable,
         :registerable,
         :recoverable, :rememberable, :validatable,
         :omniauthable,
         omniauth_providers: %i[google_oauth2 line],
         otp_secret_encryption_key: ENV["ENCRYPTION_KEY"]

  validates :name, presence: true, length: { maximum: 255 }
  validates :uid, presence: true, uniqueness: { scope: :provider }, if: -> { uid.present? }
end
```

**主要な属性**
- `uid`: OAuthプロバイダーから取得したユーザーID
- `provider`: 認証プロバイダー（`google_oauth2` or `line`）
- `email`: メールアドレス
- `name`: ユーザー名
- `otp_secret`: 二要素認証の秘密鍵（暗号化して保存）

### 実装のポイント

#### OAuthフロー

```
1. ユーザーが「Googleでログイン」をクリック
   ↓
2. Googleの認証画面へリダイレクト
   ↓
3. ユーザーが許可すると、コールバックURL（/auth/google_oauth2/callback）へリダイレクト
   ↓
4. User.from_omniauthメソッドでユーザーを作成/取得
   ↓
5. セッション確立、ログイン完了
```

#### コールバック処理のロジック

```ruby
# app/models/user.rb (抜粋)
def self.from_omniauth(auth)
  email = auth.info.email.presence || "#{auth.uid}-#{auth.provider}@example.com"
  name = auth.info.name.presence || "#{auth.provider.capitalize}ユーザー"

  # Google認証の場合、同じメールアドレスのユーザーがいれば紐付ける
  if auth.provider.to_s == "google_oauth2"
    user = find_by(email: email)
    if user
      user.update(provider: auth.provider, uid: auth.uid)
      return user
    end
  end

  # 新規ユーザー作成または既存ユーザー取得
  user = where(provider: auth.provider, uid: auth.uid).first_or_create do |user|
    user.name = name
    user.email = email
    pw = Devise.friendly_token[0, 20]
    user.password = pw
    user.password_confirmation = pw
  end

  user
end
```

**ポイント解説**
1. **メールアドレスのフォールバック**: LINEではメールアドレスが取得できない場合があるため、`#{uid}-#{provider}@example.com`の形式でダミーメールを生成
2. **Google認証の場合のアカウント統合**: すでに同じメールアドレスで登録しているユーザーがいれば、そのアカウントにOAuth情報を紐付ける
3. **ランダムパスワードの生成**: OAuth経由のユーザーはパスワードを使わないが、Deviseのバリデーションを通すためランダムパスワードを設定

### 工夫した点

#### 1. セキュリティ強化
- 二要素認証（2FA）のサポート
- OTP秘密鍵を環境変数で暗号化

```ruby
# QRコード用URIの生成
def provisioning_uri(issuer: "MyApp")
  otp_provisioning_uri(email, issuer: issuer)
end
```

#### 2. 柔軟なアカウント統合
Google認証でログインしたユーザーが、後からLINEアカウントも連携できるよう、メールアドレスをキーにした統合ロジックを実装。

#### 3. エラーハンドリング
OAuth認証失敗時のログ出力とデバッグ情報の記録により、トラブルシューティングを容易にしました。

### 課題と解決策

**課題**: LINEではメールアドレスが取得できない場合がある
**解決策**: ダミーメール（`#{uid}-line@example.com`）を生成し、ユーザー識別は`provider`と`uid`の組み合わせで行う

---

## 2. プロフィール管理機能

### 機能概要
ユーザーの基本情報（身長、性別、トレーニング強度、目標体重）を管理し、これらの情報を元にYouTube動画の推薦を行います。

### データモデル

```ruby
# app/models/profile.rb
class Profile < ApplicationRecord
  belongs_to :user

  enum :gender, { man: 0, woman: 1, other: 2 }
  enum :training_intensity, { low: 0, medium: 1, high: 2 }

  validates :height, numericality: { greater_than: 0, only_integer: true }, allow_nil: true
  validates :target_weight, numericality: { greater_than: 0, only_integer: true }, allow_nil: true

  def condition_key
    return nil if gender.nil? || training_intensity.nil?
    "#{gender}_#{training_intensity}"
  end
end
```

**主要な属性**
- `height`: 身長（整数、任意）
- `gender`: 性別（enum: man, woman, other）
- `training_intensity`: トレーニング強度（enum: low, medium, high）
- `target_weight`: 目標体重（整数、任意）

### 実装のポイント

#### enumの活用
Rails 7の`enum`機能を使い、性別とトレーニング強度を整数で管理しています。

**メリット**
- データベースに整数で保存されるため、省スペース
- `profile.gender` で "man" などの文字列が取得できる
- `profile.man?` のような真偽値メソッドが自動生成される

#### condition_keyメソッド
```ruby
def condition_key
  return nil if gender.nil? || training_intensity.nil?
  "#{gender}_#{training_intensity}"
end
```

このメソッドは、性別とトレーニング強度を組み合わせて一意のキー（例: `man_high`, `woman_low`）を生成します。

**使用例**
```ruby
profile.condition_key  # => "man_high"
```

この`condition_key`は、後述するYouTube動画推薦機能で、**同じ条件のユーザーに対してキャッシュされた動画を共有する**ために使用されます。

### 工夫した点

#### 1. バリデーションの柔軟性
`allow_nil: true`により、プロフィールの一部項目が未入力でも保存可能にしています。これにより、ユーザーは必須項目だけを入力してスタートできます。

#### 2. enumの可読性向上
コード内で`profile.gender == 0`ではなく`profile.man?`と書けるため、可読性が向上します。

---

## 3. 身体記録機能

### 機能概要
毎日の体重、体脂肪率、身体の写真を記録する機能です。写真はWebカメラで撮影するか、ファイルをアップロードできます。

### データモデル

```ruby
# app/models/body_record.rb
class BodyRecord < ApplicationRecord
  belongs_to :user
  has_one_attached :photo

  validates :weight, numericality: { greater_than_or_equal_to: 0, less_than_or_equal_to: 300 }, allow_blank: true
  validates :body_fat, numericality: { greater_than_or_equal_to: 0, less_than_or_equal_to: 100 }, allow_blank: true
end
```

**主要な属性**
- `recorded_at`: 記録日時
- `weight`: 体重（0〜300kg）
- `body_fat`: 体脂肪率（0〜100%）
- `fat_mass`: 脂肪量（自動計算）
- `photo`: 身体の写真（Active Storage）

### 実装のポイント

#### 1. Active Storageによる画像管理

**Active Storageとは**
Rails標準の画像アップロード機能で、S3やローカルストレージに画像を保存できます。

```ruby
has_one_attached :photo
```

この1行で、以下の機能が使えるようになります：
- `body_record.photo.attach(file)` - 画像をアップロード
- `body_record.photo.attached?` - 画像が存在するか確認
- `body_record.photo.purge` - 画像を削除

#### 2. Service層による画像処理

```ruby
# app/services/body_record_photo_service.rb
class BodyRecordPhotoService
  def initialize(body_record)
    @body_record = body_record
  end

  def attach_processed_photo(photo_param)
    begin
      # ImageProcessing + MiniMagickで画像をリサイズ・圧縮
      processed = ImageProcessing::MiniMagick
                    .source(photo_param.tempfile)
                    .resize_to_limit(600, 600)  # 最大600x600px
                    .quality(60)                # JPEG品質60%
                    .call

      # 1MB以上の場合、さらに品質を下げる
      if processed.size > 1024 * 1024
        processed = ImageProcessing::MiniMagick
                      .source(processed)
                      .quality(50)
                      .call
      end

      @body_record.photo.attach(
        io: processed,
        filename: photo_param.original_filename,
        content_type: photo_param.content_type
      )
    rescue => e
      # エラー時は元の画像をそのまま保存
      @body_record.photo.attach(photo_param)
    end
  end
end
```

**処理フロー**
1. アップロードされた画像を600x600pxにリサイズ
2. JPEG品質を60%に圧縮
3. ファイルサイズが1MB以上なら、さらに品質を50%に下げる
4. 処理に失敗した場合は、元の画像をそのまま保存

**メリット**
- ストレージ容量の節減
- 画像読み込み速度の向上
- ユーザー体験の改善

#### 3. Controllerでの日付処理

```ruby
# app/controllers/body_records_controller.rb (抜粋)
def create
  date = begin
    Date.parse(body_record_params[:recorded_at])
  rescue ArgumentError, TypeError
    Date.current
  end
  recorded_at = date.beginning_of_day

  # 同じ日のレコードがあれば更新、なければ新規作成
  @body_record = current_user.body_records.find_or_initialize_by(
    recorded_at: recorded_at
  )

  @body_record.assign_attributes(body_record_params.except(:photo))
  @body_record.recorded_at = recorded_at

  if params[:body_record][:photo].present?
    BodyRecordPhotoService.new(@body_record).attach_processed_photo(params[:body_record][:photo])
  end

  if @body_record.save
    redirect_to top_body_records_path(selected_date: @body_record.recorded_at),
                success: @body_record.previously_new_record? ? "身体情報を登録しました" : "身体情報を更新しました"
  else
    flash.now[:danger] = "身体情報の登録・更新に失敗しました"
    render :new, status: :unprocessable_entity
  end
end
```

**ポイント解説**
1. **日付パース**: ユーザー入力の日付を`Date.parse`でパース。失敗時は今日の日付を使用
2. **beginning_of_day**: 日付を`2025-01-15 00:00:00`の形式に統一（時刻部分をゼロにする）
3. **find_or_initialize_by**: 同じ日のレコードがあれば取得、なければ新規作成
4. **previously_new_record?**: 新規作成か更新かを判定し、適切なメッセージを表示

#### 4. Webカメラ連携（Stimulus Controller）

```javascript
// app/javascript/controllers/camera_controller.js (抜粋)
export default class extends Controller {
  static targets = [
    "previewContainer", "placeholder",
    "nativeCameraButton", "nativeCameraInput", "fileInput"
  ]

  connect() {
    // ファイル選択時プレビュー
    this.fileInputTarget.addEventListener("change", this.previewUpload.bind(this))

    // ネイティブカメラ撮影時プレビュー
    this.nativeCameraInputTarget.addEventListener("change", this.previewNativeCamera.bind(this))

    // スマホ判定
    const ua = navigator.userAgent
    const isMobile = /Mobi|Android|iPhone|iPod/.test(ua)

    if (!isMobile) {
      // PCではネイティブカメラボタンを隠す
      this.nativeCameraButtonTarget.classList.add("hidden")
    }
  }

  openNativeCamera() {
    // ネイティブカメラアプリを起動
    this.nativeCameraInputTarget.click()
  }

  previewNativeCamera(event) {
    const file = event.target.files[0]
    if (!file) return

    // ファイルサイズチェック（10MB制限）
    if (file.size > 10 * 1024 * 1024) {
      this._showError("ファイルサイズが大きすぎます。10MB以下のファイルを選択してください。")
      return
    }

    // 画像ファイルかチェック
    if (!file.type.startsWith('image/')) {
      this._showError("画像ファイルを選択してください。")
      return
    }

    // プレビュー表示
    this._displayImage(file)
    this._showSuccess("写真を撮影しました")
  }

  _displayImage(file) {
    const url = URL.createObjectURL(file)

    // プレビューエリアをクリア
    this.previewContainerTarget.innerHTML = ""

    // 画像を表示
    const img = document.createElement('img')
    img.src = url
    img.className = 'w-full h-full object-cover rounded'
    img.setAttribute('data-camera-target', 'placeholder')
    img.alt = '身体写真'
    this.previewContainerTarget.appendChild(img)

    // ファイルフィールドにセット
    const dt = new DataTransfer()
    dt.items.add(file)
    this.nativeCameraInputTarget.files = dt.files
    this.fileInputTarget.files = dt.files
  }
}
```

**Stimulus Controllerの役割**
1. **デバイス判定**: User-Agentでスマホ/PCを判定し、PCではカメラボタンを非表示
2. **ファイルバリデーション**: ファイルサイズ（10MB以下）と形式（画像のみ）をチェック
3. **プレビュー表示**: `URL.createObjectURL`で画像をプレビュー
4. **DataTransferでファイルセット**: 撮影した画像を両方のinputフィールドにセット

### 工夫した点

#### 1. 1日1レコードの設計
`find_or_initialize_by(recorded_at: date.beginning_of_day)`により、同じ日のレコードは1つだけ存在するようにしています。これにより、ユーザーが何度も記録を更新しても、データの整合性が保たれます。

#### 2. 画像の自動圧縮
`BodyRecordPhotoService`で画像を自動圧縮することで、ユーザーはファイルサイズを気にせずアップロードできます。

#### 3. スマホでのWebカメラ対応
`<input type="file" accept="image/*" capture="environment">`により、スマホではネイティブカメラアプリが起動し、直感的に写真を撮影できます。

### 課題と解決策

**課題1**: 画像アップロード時のエラーハンドリング
**解決策**: `begin...rescue`でエラーをキャッチし、処理失敗時は元の画像をそのまま保存

**課題2**: タイムゾーンの問題（UTC vs JST）
**解決策**: `beginning_of_day`を使用し、日付を00:00:00に統一することで、タイムゾーンのズレを回避

---

## 4. 進捗可視化機能

### 機能概要
Chart.jsを使った体重・体脂肪率のグラフ表示と、スライダーで写真の変化を確認する機能です。

### 技術選定理由

**なぜChart.jsを選んだのか**
- 軽量で高速
- レスポンシブ対応が容易
- プラグインシステムで拡張性が高い
- Rails + Stimulusとの相性が良い

### 実装のポイント

#### 1. Service層でのデータ整形

```ruby
# app/services/progress_data_service.rb
class ProgressDataService
  def initialize(user, period)
    @user = user
    @period = period.presence || "3m"
  end

  def call
    {
      graph_records: graph_records,
      dates: graph_records.map { |r| r.recorded_at.strftime("%Y-%m-%d") },
      weight_values: graph_records.map(&:weight),
      fat_values: graph_records.map(&:body_fat),
      all_graph_records: all_graph_records,
      target_weight: @user.profile&.target_weight,
      first_record: graph_records.first,
      last_record: graph_records.last,
      body_records_with_photo: body_records_with_photo,
      all_photos: all_photos
    }
  end

  private

  def graph_records
    @graph_records ||= base_query.order(:recorded_at)
  end

  def base_query
    case @period
    when "1w" then @user.body_records.where("recorded_at >= ?", 1.week.ago)
    when "3w" then @user.body_records.where("recorded_at >= ?", 3.weeks.ago)
    when "1m" then @user.body_records.where("recorded_at >= ?", 1.month.ago)
    else # "3m"
      @user.body_records.where("recorded_at >= ?", 3.months.ago)
    end
  end

  def all_graph_records
    @user.body_records.order(:recorded_at).pluck(:recorded_at, :weight, :body_fat)
  end

  def body_records_with_photo
    @user.body_records.with_attached_photo.order(:recorded_at).select { |r| r.photo.attached? }
  end
end
```

**Service層のメリット**
- Controllerがシンプルになる
- テストが書きやすい
- データ整形ロジックを一箇所に集約

#### 2. Stimulus ControllerでChart.js描画

```javascript
// app/javascript/controllers/progress_controller.js (抜粋)
import Chart from "chart.js/auto"

export default class extends Controller {
  static values = {
    labels: Array,
    weights: Array,
    fatRates: Array,
    targetWeight: Number,
    allRecords: Array
  }

  connect() {
    this.currentPeriod = "3m"
    this.renderChart("3m")
    this.updateStatsTable("3m")
  }

  renderChart(period = "3m") {
    const ctx = this.weightChartTarget.getContext("2d")
    const chart = Chart.getChart(ctx)
    if (chart) chart.destroy()  // 既存のチャートを破棄

    const rows = this.buildChartData(period)
    const labels = rows.map(r => {
      const t = new Date(r.label)
      return `${t.getMonth() + 1}/${t.getDate()}`
    })
    const weights = rows.map(r => r.weight)
    const fats = rows.map(r => r.fat)

    // Y軸の範囲を計算
    const vw = weights.filter(v => v !== null)
    const vf = fats.filter(v => v !== null)
    let wMin = vw.length ? Math.floor(Math.min(...vw)) - 5 : undefined
    let wMax = vw.length ? Math.ceil(Math.max(...vw)) + 5 : undefined

    // 目標体重がグラフ範囲外なら、範囲を拡大
    const target = this.targetWeightValue
    if (target && vw.length > 0) {
      const min = Math.min(...vw)
      const max = Math.max(...vw)
      if (target < min) wMin = Math.floor(target) - 5
      if (target > max) wMax = Math.ceil(target) + 5
    }

    const isMobile = window.innerWidth < 768

    this.chart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "体重(kg)",
            data: weights,
            borderColor: "rgba(255,99,132,0.9)",
            backgroundColor: "rgba(255,99,132,0.2)",
            yAxisID: "y1",
            spanGaps: true,  // データがない日は線で繋ぐ
            borderWidth: isMobile ? 2 : 3,
            pointRadius: isMobile ? 3 : 4
          },
          {
            label: "体脂肪率(%)",
            data: fats,
            borderColor: "rgba(75,192,192,0.7)",
            backgroundColor: "rgba(75,192,192,0.2)",
            yAxisID: "y2",
            spanGaps: true,
            borderWidth: isMobile ? 2 : 3,
            pointRadius: isMobile ? 3 : 4
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: { display: true, text: "日付" },
            ticks: { maxTicksLimit: isMobile ? 7 : 10 }
          },
          y1: {
            type: "linear",
            position: "left",
            min: wMin,
            max: wMax,
            title: { display: true, text: "体重(kg)" }
          },
          y2: {
            type: "linear",
            position: "right",
            title: { display: true, text: "体脂肪率(%)" },
            grid: { drawOnChartArea: false }  // 右軸のグリッド線を非表示
          }
        }
      },
      plugins: [{
        id: "targetWeightMarker",
        afterDraw: (chart) => {
          if (!target) return
          const y = chart.scales["y1"].getPixelForValue(target)
          const ctx = chart.ctx
          const radius = isMobile ? 10 : 12

          // 目標体重を示す円を描画
          ctx.beginPath()
          ctx.arc(chart.chartArea.left - radius - 6, y, radius, 0, 2 * Math.PI)
          ctx.fillStyle = "rgba(139, 92, 246, 0.8)"
          ctx.fill()

          // 円の中に数値を表示
          ctx.font = `bold ${isMobile ? 10 : 12}px sans-serif`
          ctx.fillStyle = "#fff"
          ctx.textAlign = "center"
          ctx.textBaseline = "middle"
          ctx.fillText(String(target), chart.chartArea.left - radius - 6, y)

          // 点線を描画
          ctx.setLineDash([5, 5])
          ctx.strokeStyle = "rgba(139, 92, 246, 0.8)"
          ctx.lineWidth = 2
          ctx.beginPath()
          ctx.moveTo(chart.chartArea.left, y)
          ctx.lineTo(chart.chartArea.right, y)
          ctx.stroke()
        }
      }]
    })
  }

  buildChartData(period) {
    // 期間の開始日を計算
    const now = new Date()
    let start = new Date(now)
    switch (period) {
      case "1w": start = new Date(now - 7 * 86400000); break
      case "3w": start = new Date(now - 21 * 86400000); break
      case "1m": start.setMonth(now.getMonth() - 1); break
      default: start.setMonth(now.getMonth() - 3)
    }

    // 日付の配列を生成（開始日〜今日）
    const range = []
    const cur = new Date(start)
    while (cur <= now) {
      range.push(cur.toISOString().slice(0, 10))
      cur.setDate(cur.getDate() + 1)
    }

    // 記録データをマップに変換
    const map = {}
    this.labelsValue.forEach((d, i) => {
      map[d] = {
        w: parseFloat(this.weightsValue[i]) || undefined,
        f: parseFloat(this.fatRatesValue[i]) || undefined
      }
    })

    // 日付配列とマップを結合
    return range.map(d => ({
      label: d,
      weight: map[d]?.w ?? null,
      fat: map[d]?.f ?? null
    }))
  }
}
```

**ポイント解説**

1. **二軸グラフ**: 体重（左軸）と体脂肪率（右軸）を同時に表示
2. **spanGaps: true**: データがない日も線で繋ぐ
3. **レスポンシブ対応**: スマホではポイントサイズやラベル数を調整
4. **カスタムプラグイン**: 目標体重を示す円と点線を描画
5. **動的な範囲調整**: 目標体重がグラフ範囲外なら、範囲を自動拡大

#### 3. 写真のスライダー表示

```javascript
// app/javascript/controllers/photo_switcher_controller.js (抜粋)
export default class extends Controller {
  static targets = ["image", "slider"]

  connect() {
    this.allPhotos = JSON.parse(this.element.dataset.photos)
    this.period = "3m"
    this.setPeriod(this.period)
  }

  setPeriod(period) {
    this.period = period

    // 期間ごとの日付範囲を計算
    const now = new Date()
    let start = new Date(now)
    switch (period) {
      case "1w": start = new Date(now.getTime() - 7 * 86400000); break
      case "3w": start = new Date(now.getTime() - 21 * 86400000); break
      case "1m": start.setMonth(now.getMonth() - 1); break
      default: start.setMonth(now.getMonth() - 3)
    }

    const startStr = start.toISOString().slice(0, 10)
    const jstToday = this.element.dataset.jstToday

    // フィルタリング
    this.photos = this.allPhotos.filter(p => p.date >= startStr && p.date <= jstToday)

    // 画像・スライダー更新
    this.updateImage(0)
    const slider = this.targets.find("slider")
    if (slider) {
      slider.max = this.photos.length
      slider.value = 1
      slider.style.display = this.photos.length > 1 ? '' : 'none'
    }
  }

  slide() {
    const slider = this.targets.find("slider")
    const index = parseInt(slider?.value || 1, 10) - 1
    this.updateImage(index)
  }

  updateImage(index) {
    if (!this.hasImageTarget) return

    if (this.photos.length === 0) {
      // プレースホルダー画像を使用
      const placeholder = this.element.dataset.placeholder || '/assets/avatar_placeholder.png'
      this.imageTarget.src = placeholder
    } else {
      const photo = this.photos[index]
      if (photo && photo.url) {
        this.imageTarget.src = photo.url
      } else {
        const placeholder = this.element.dataset.placeholder || '/assets/avatar_placeholder.png'
        this.imageTarget.src = placeholder
      }
    }
  }
}
```

**スライダーの動作**
1. 期間（1週間、3週間、1ヶ月、3ヶ月）を選択
2. 該当期間の写真をフィルタリング
3. スライダーで写真を切り替え

### 工夫した点

#### 1. 目標体重のビジュアル表示
Chart.jsのカスタムプラグインで、目標体重を示す円と点線をグラフ上に描画しました。これにより、ユーザーは一目で目標までの距離を把握できます。

#### 2. 統計情報の表示
グラフの下に、以下の統計情報を表示しています：
- 初回体重 / 最新体重
- 初回体脂肪率 / 最新体脂肪率
- 初回脂肪量 / 最新脂肪量
- 目標まであと○○kg

#### 3. レスポンシブ対応
スマホとPCで、グラフの線の太さやポイントサイズ、ラベル数を調整し、最適な表示を実現しました。

### 課題と解決策

**課題**: データがない日が多いと、グラフが途切れて見づらい
**解決策**: `spanGaps: true`でデータがない日も線で繋ぐことで、推移を把握しやすくしました

**課題**: 写真が大量にある場合、スライダーの動作が重くなる
**解決策**: 期間フィルタリングにより、表示する写真を制限しました

---

## 5. YouTube動画連携機能

### 機能概要
ユーザーのプロフィール（性別、トレーニング強度）に基づいて、YouTube Data APIから最適なトレーニング動画を推薦します。

### 技術選定理由

**YouTube Data API v3を選んだ理由**
- 動画の検索、情報取得が可能
- 無料プランでも1日10,000クエリまで利用可能
- 公式APIで安定性が高い

### 実装のポイント

#### 1. YouTube API Service

```ruby
# app/services/youtube_api_service.rb
class YoutubeApiService
  require "net/http"
  require "json"

  def initialize
    @api_key = ENV["YOUTUBE_API_KEY"] || Rails.application.credentials.youtube_api_key
    @base_url = "https://www.googleapis.com/youtube/v3"
    Rails.logger.info "YouTube API Service initialized. API key present: #{@api_key.present?}"
  end

  def fetch_video_info(video_id)
    unless @api_key.present?
      Rails.logger.warn "YouTube API key is not configured"
      return {}
    end

    begin
      url = "#{@base_url}/videos?part=snippet&id=#{video_id}&key=#{@api_key}"
      uri = URI(url)
      response = Net::HTTP.get_response(uri)

      if response.is_a?(Net::HTTPSuccess)
        data = JSON.parse(response.body)
        items = data["items"]

        if items.present?
          snippet = items.first["snippet"]
          {
            title: snippet["title"],
            channel_title: snippet["channelTitle"],
            thumbnail_url: snippet["thumbnails"]["default"]["url"],
            published_at: snippet["publishedAt"]
          }
        else
          Rails.logger.warn "No items found in YouTube API response"
          {}
        end
      else
        Rails.logger.error "YouTube API error: #{response.code} - #{response.body}"
        {}
      end
    rescue => e
      Rails.logger.error "YouTube API request failed: #{e.message}"
      {}
    end
  end

  def self.fetch_video_info(video_id)
    new.fetch_video_info(video_id)
  end
end
```

**ポイント解説**
1. **環境変数でAPI Key管理**: `ENV["YOUTUBE_API_KEY"]`で安全に管理
2. **エラーハンドリング**: API失敗時は空のHashを返す
3. **ログ出力**: トラブルシューティング用にログを詳細に記録

#### 2. Recommended Video Service

```ruby
# app/services/recommended_video_service.rb
class RecommendedVideoService
  def initialize(user)
    @user = user
    @profile = user.profile
    @condition_key = @profile&.condition_key
  end

  def fetch_and_cache_videos
    return [] unless @profile && @condition_key

    service = YoutubeService.new
    videos_data = service.fetch_videos(
      gender: @profile.gender,
      intensity: @profile.training_intensity,
      target_count: 5,
      max_results: 50
    )

    saved_videos = []
    videos_data.each do |video_data|
      break if saved_videos.size >= 5
      video = create_video_from_data(video_data)
      saved_videos << video if video
    end

    RecommendedVideo.where(condition_key: @condition_key).limit(5)
  end

  def clear_cache
    RecommendedVideo.where(condition_key: @condition_key).destroy_all.size
  end

  private

  def create_video_from_data(video_data)
    video_id = video_data.dig("id", "videoId")
    return nil unless video_id

    RecommendedVideo.create(
      video_id: video_id,
      title: video_data.dig("snippet", "title"),
      thumbnail_url: video_data.dig("snippet", "thumbnails", "medium", "url"),
      channel_title: video_data.dig("snippet", "channelTitle"),
      view_count: video_data.dig("statistics", "viewCount")&.to_i || 0,
      condition_key: @condition_key,
      fetched_at: Time.current
    )
  rescue ActiveRecord::RecordNotUnique
    Rails.logger.warn "Video #{video_id} for key #{@condition_key} already exists. Skipping."
    nil
  rescue => e
    Rails.logger.error "Failed to save video #{video_id} for key #{@condition_key}: #{e.message}"
    nil
  end
end
```

**キャッシュ戦略**
1. `condition_key`（例: `man_high`）をキーに、動画を`RecommendedVideo`テーブルに保存
2. 同じ条件のユーザーには、キャッシュされた動画を提供
3. これにより、APIクエリ数を大幅に削減

**動作フロー**
```
1. ユーザーがプロフィールを登録（例: 男性、高強度）
   ↓
2. condition_key = "man_high"
   ↓
3. RecommendedVideoテーブルに"man_high"の動画があるか確認
   ↓
4. あれば、キャッシュから返す
   ↓
5. なければ、YouTube APIで検索
   ↓
6. 取得した動画をRecommendedVideoに保存
   ↓
7. 次回以降は、キャッシュから返す
```

### 工夫した点

#### 1. APIクエリ数の削減
`condition_key`によるキャッシュ機能により、同じ条件のユーザーには同じ動画を提供し、APIクエリ数を削減しました。

**例**
- ユーザーA（男性、高強度）が動画を取得 → API呼び出し
- ユーザーB（男性、高強度）が動画を取得 → キャッシュから返す（API呼び出しなし）

#### 2. エラーハンドリング
API失敗時やレスポンスが空の場合でも、アプリケーションがエラーにならないよう、空のHashや空の配列を返す設計にしました。

#### 3. ログ出力
API呼び出しのリクエスト/レスポンスを詳細にログ出力し、トラブルシューティングを容易にしました。

### 課題と解決策

**課題**: YouTube APIのクォータ制限（1日10,000クエリ）
**解決策**: `condition_key`によるキャッシュ機能で、同じ条件のユーザーにはキャッシュを返す

**課題**: 検索結果の精度
**解決策**: `YoutubeService`で検索キーワードを最適化し、view_countでソートして人気動画を優先

---

## 6. お気に入り動画管理機能

### 機能概要
ユーザーが任意のYouTube動画URLを登録し、お気に入りとして管理できる機能です。

### 実装のポイント

#### Favorite Video Service

```ruby
# app/services/favorite_video_service.rb
class FavoriteVideoService
  def initialize(user)
    @user = user
  end

  def add_favorite_video(url)
    return { success: false, message: "URLを入力してください" } if url.blank?

    video_id = extract_video_id(url)
    return { success: false, message: "正しいYouTube URLを入力してください" } if video_id.blank?

    return { success: false, message: "お気に入り動画は最大5件までです" } if @user.favorite_videos.count >= 5

    if @user.favorite_videos.find_by(youtube_url: url)
      return { success: false, message: "既に登録されている動画です" }
    end

    video_info = YoutubeApiService.fetch_video_info(video_id)

    # API失敗時のフォールバック
    if video_info.empty?
      video_info = {
        title: "動画 #{video_id}",
        channel_title: "不明なチャンネル",
        thumbnail_url: "https://img.youtube.com/vi/#{video_id}/default.jpg"
      }
    end

    fav = @user.favorite_videos.build(
      youtube_url: url,
      title: video_info[:title] || "動画 #{video_id}",
      channel_title: video_info[:channel_title] || "不明なチャンネル",
      thumbnail_url: video_info[:thumbnail_url] || "https://img.youtube.com/vi/#{video_id}/default.jpg"
    )

    if fav.save
      { success: true, favorite_video: fav }
    else
      { success: false, message: fav.errors.full_messages.join(", ") }
    end
  rescue => e
    { success: false, message: "エラーが発生しました: #{e.message}" }
  end

  private

  def extract_video_id(url)
    regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/
    match = url.match(regex)
    match[1] if match
  end
end
```

**ポイント解説**

1. **URL解析**: 正規表現でYouTube URLからvideo_idを抽出
   - `https://www.youtube.com/watch?v=dQw4w9WgXcQ` → `dQw4w9WgXcQ`
   - `https://youtu.be/dQw4w9WgXcQ` → `dQw4w9WgXcQ`
   - `https://www.youtube.com/embed/dQw4w9WgXcQ` → `dQw4w9WgXcQ`

2. **バリデーション**
   - URLが空でないか
   - 正しいYouTube URLか
   - お気に入りが5件未満か
   - 既に登録されていないか

3. **API失敗時のフォールバック**
   - API呼び出しに失敗しても、デフォルトのサムネイルURLを使用
   - `https://img.youtube.com/vi/{video_id}/default.jpg`で直接サムネイルを取得

4. **エラーレスポンス**
   - 成功/失敗を示す`success`フラグ
   - エラーメッセージを`message`に格納

### 工夫した点

#### 1. 柔軟なURL形式対応
正規表現で複数のYouTube URL形式に対応しました。

#### 2. API失敗時のグレースフルデグラデーション
API呼び出しに失敗しても、デフォルトの情報で動画を登録できるようにしました。

#### 3. 5件制限
お気に入りを5件までに制限することで、ユーザーが厳選した動画を管理しやすくしました。

---

## 7. LINE Bot リマインド機能

### 機能概要
LINEと連携し、ユーザーが指定した時刻にトレーニングのリマインド通知を送信する機能です。

### 実装のポイント

#### LINE Bot Service

```ruby
# app/services/line_bot_service.rb
class LineBotService
  def initialize(event)
    @event = event
  end

  def handle_event
    return unless @event.is_a?(Line::Bot::Event::Message) && @event.message["type"] == "text"

    user = User.find_by(line_user_id: @event["source"]["userId"])

    if user && user.uid.present?
      handle_user_message(user)
    else
      reply_message(@event["replyToken"], {
        type: "text",
        text: "この機能を利用するにはマイページでLINE連携が必要です。"
      })
    end
  end

  private

  def handle_user_message(user)
    text = @event.message["text"].strip

    case text
    when "通知"
      reply_message(@event["replyToken"], quick_reply_message)
    when /\A\d{1,2}:\d{2}\z/
      # 時刻形式（例: 12:00）
      target_time = Time.current.change(
        hour: text.split(":")[0].to_i,
        min: text.split(":")[1].to_i
      )
      NotificationJob.set(wait_until: target_time).perform_later(user.id)
      reply_message(@event["replyToken"], {
        type: "text",
        text: "通知を予約しました"
      })
    when "リスケ"
      reply_message(@event["replyToken"], {
        type: "text",
        text: "新しい通知時刻を入力してください（例: 12:00）"
      })
    when "通知取り消し"
      # NotificationJobのキャンセル処理
      reply_message(@event["replyToken"], {
        type: "text",
        text: "通知を解除しました"
      })
    else
      # リスケ状態の管理は不要。時刻入力があれば予約し直す。
      if text =~ /\A\d{1,2}:\d{2}\z/
        target_time = Time.current.change(
          hour: text.split(":")[0].to_i,
          min: text.split(":")[1].to_i
        )
        NotificationJob.set(wait_until: target_time).perform_later(user.id)
        reply_message(@event["replyToken"], {
          type: "text",
          text: "通知時間を変更しました"
        })
      end
    end
  end

  def reply_message(token, message)
    res = LineClient.client.reply_message(token, message)
    Rails.logger.info "LINE reply response: #{res.body} (#{res.code})"
  end

  def quick_reply_message
    {
      type: "text",
      text: "通知時刻を入力してください（例: 12:00）"
    }
  end
end
```

**動作フロー**

```
1. ユーザーがLINE Botに「通知」と送信
   ↓
2. Bot「通知時刻を入力してください（例: 12:00）」と返信
   ↓
3. ユーザーが「12:00」と送信
   ↓
4. NotificationJobを12:00に予約
   ↓
5. 12:00になると、NotificationJobが実行され、LINEにメッセージ送信
```

**正規表現によるメッセージ判定**
```ruby
when /\A\d{1,2}:\d{2}\z/
```
この正規表現は、`12:00`や`9:30`などの時刻形式にマッチします。

**ジョブのスケジューリング**
```ruby
NotificationJob.set(wait_until: target_time).perform_later(user.id)
```
Sidekiqなどのバックグラウンドジョブシステムで、指定時刻にジョブを実行します。

### 工夫した点

#### 1. 柔軟なメッセージハンドリング
ユーザーのメッセージを正規表現で判定し、様々な入力形式に対応しました。

#### 2. 状態管理不要な設計
リスケや通知取り消しを、状態を保持せずに実装しました。これにより、シンプルな実装を実現しています。

#### 3. エラーハンドリング
LINE連携がないユーザーには、適切なメッセージを返す設計にしました。

### 課題と解決策

**課題**: タイムゾーン対応（UTC vs JST）
**解決策**: `Time.current.change`でJSTの時刻を指定し、正しい時刻に通知を送信

**課題**: 通知の信頼性確保
**解決策**: Sidekiqなどのバックグラウンドジョブシステムを使用し、Rails再起動時もジョブが失われないようにしました

---

## まとめ

### 実装を通じて学んだこと

#### 技術的な学び

1. **Service層の重要性**
   - Fat Controllerを避け、責務を分離することで、保守性が向上
   - 単体テストが書きやすくなる

2. **Hotwire (Turbo + Stimulus) の威力**
   - JavaScriptフレームワーク（React, Vue.js）なしで、リッチなUIを実装可能
   - Rails標準技術なので、学習コストが低い

3. **Active Storageの便利さ**
   - 画像アップロード機能が1行で実装できる
   - ImageProcessingとの組み合わせで、画像処理も簡単

4. **外部API連携のベストプラクティス**
   - エラーハンドリングを徹底する
   - キャッシュ機能でAPIクエリ数を削減
   - ログ出力でトラブルシューティングを容易にする

#### 設計の学び

1. **ユーザー体験を最優先**
   - 記録項目を任意にすることで、ユーザーの負担を軽減
   - スマホでのWebカメラ対応で、撮影が簡単に

2. **パフォーマンスの最適化**
   - 画像の自動圧縮でストレージ節約
   - Service層でデータ整形し、Viewはシンプルに

3. **エラーに強い設計**
   - API失敗時のフォールバック処理
   - バリデーションの柔軟性

### 今後の改善点

#### 機能拡張
- **AI機能の追加**: 写真からボディラインを解析し、変化を数値化
- **SNS共有機能**: 進捗をTwitterやInstagramでシェア
- **グループ機能**: 友達と一緒にダイエット

#### パフォーマンス改善
- **CDNの導入**: 画像配信を高速化
- **N+1クエリの解消**: `includes`や`joins`で最適化
- **キャッシュ戦略の強化**: Redis導入で表示速度向上

#### リファクタリング
- **FormObject導入**: バリデーションロジックをさらに分離
- **Repository Pattern**: データアクセスロジックを抽象化
- **テストカバレッジ向上**: RSpecで90%以上のカバレッジを目指す

### 参考資料
- [Ruby on Rails ガイド](https://railsguides.jp/)
- [Google OAuth 2.0 ドキュメント](https://developers.google.com/identity/protocols/oauth2)
- [YouTube Data API](https://developers.google.com/youtube/v3)
- [LINE Messaging API](https://developers.line.biz/ja/docs/messaging-api/)
- [Hotwire公式ドキュメント](https://hotwired.dev/)
- [Chart.js公式ドキュメント](https://www.chartjs.org/)
- [Stimulus Handbook](https://stimulus.hotwired.dev/handbook/introduction)
- [Active Storage Overview](https://guides.rubyonrails.org/active_storage_overview.html)
